#!/bin/bash
# your average toy bash irc script ...
# June 2012. Scott Nicholas <mute@scottn.us>

# config
declare -A bot=(
	[nick]=neutronbot
	[cmdch]='$'
	[user]=mute
	[name]='bashy bot!'
)
servers=(
	verne.freenode.net
	chat.us.freenode.net
	chat.freenode.net
)
# ['channel']='flags'
# flags are:
#   u - catch urls: shorten and show title
#   k - scan for karma
#   e - VM exec
## these are actually saved in the savefile, so probably move it after
## first run.
declare -A channels=(
	['#coredump']='euk'
	['#vectori']='euk'
)
declare -A acl=(
	['.*!.*mute@scottn.us']=3
)
savefile='infobot.save'
# weather command: use personal weather stations
pws=1

# flood control
_sendq_RATE=5 _sendq_PER=8

json() { ./jshon ${@/#/-e } -u 2>/dev/null; }

runqemu() {
timeout --kill-after 6 4 /home/mute/qemu-serial/qemu -L /home/mute/qemu-serial \
-hda hda -net none -m 32 -nographic -vga none -loadvm "root$1" <<< "\
$RANDOM
$(date -u +%s)
$2"
}

#################################################
####### END OF USER-SERVICABLE VARIABLES ########
#################################################

# globals. that you don't touch. not config items
declare -A karma=() info=()
_IFS=$IFS	#save it.
_sendq_MAX=$((_sendq_RATE * _sendq_PER))
_sendq_allowance=$_sendq_MAX

# these need to survive during reload
#   arrays: _sendq karma _origargs
(( reloads++ )) || _origargs=( "$0" "$@" )
: ${nextserv:=0} ${reconnects:=0}
export reloads curnick nextserv reconnects _sendq_allowance

### command table. [command]=access level.
declare -A cmdtbl=(
	[say]=0		[tell]=1	[karma]=0
	[whoami]=0	[uptime]=0	[top10]=0
	[google]=0	[wx]=0		[wxs]=0
	[wxf]=0		[cmds]=0	[help]=0
	[cat]=1		[forget]=1	[info]=1
	[pws]=1		[chan]=1
	[dropq]=3	[reload]=3	[raw]=3
)

### start with the simple stuff
is_chan()   { [[ $1 = '#'* ]]; }
irc_send()  { printf '%s\r\n' "$1" >&3; }
irc_sendq() { _sendq=("$1" "${_sendq[@]}"); }
privmsg()   { irc_sendq "PRIVMSG $1 :$2"; }
notice()    { irc_sendq "NOTICE $1 :$2"; }

### connection handling
irc_connect() {
	local host port maxtries=3

	# bypass connection, we are reloading and already connected.
	if [[ $curnick ]]; then
		echo "*** Already connected."
		return 0
	fi
	while (( reconnects++ < maxtries )); do
		IFS=: read -r host port <<< "${servers[nextserv]}"
		echo "*** Connecting to $host:${port:=6667} ..."
		# incr now so it's ready in case of any sort of disconnect later
		(( nextserv=(nextserv+1)%${#servers} ))
		if exec 3<>"/dev/tcp/$host/$port"; then
			echo "*** Sending login ..."
			irc_send "NICK ${bot["nick"]}"
			irc_send "USER ${bot["user"]:-irc} user host :${bot["name"]:-bash bot}"

			IFS=,
			irc_send "JOIN :${!channels[*]}"
			IFS=$_IFS
			break
		fi
		# failed to connect ...
	done

	return 0
}

### incoming handling
irc_parse() {
	local line=$1
	local src cmd dest params

	if [[ $line = :* ]]; then
		read -r src cmd dest params <<< "${line:1}"
	else
		read -r cmd dest params <<< "$line"
	fi

	case "$cmd" in
		PING)		irc_send "PONG $dest" ;;
		PRIVMSG)	h_privmsg "$src" "$dest" "${params:1}" ;;
		QUIT)		h_leave "$src" "$dest" quit ;;
		PART)		h_leave "$src" "$dest" part ;;
		JOIN)		h_join "$src" "$dest" ;;
		001)		curnick=$dest; reconnects=0 ;;
		# useless noise
		002|003|004|005|251|252|253|254|255|265|266|250|375|372|376|332|333)
				;;	#do nothing
		[0-9][0-9][0-9])
				printf '### %s\n' "${params/:/}" ;;
		*)		printf '<<< %s\n' "$line" ;;
	esac
}

h_leave() {
	local src=$1 dest=$2 msg=$2 how=${3^^}
	local nick user host

	IFS='!@' read -r nick user host <<< "$src"
	if [[ $how = QUIT ]]; then
		echo "*** $nick QUIT ($msg)"
	else
		echo "*** $nick PART $dest"
	fi
}

h_join() {
	local src=$1 dest=$2
	local nick user host

	IFS='!@' read -r nick user host <<< "$src"
	echo "*** $nick JOIN $dest"
}

h_privmsg() {
	local src=$1 dest=$2 msg=$3
	local nick user host
	local direct=0 sh cmd args u alvl=0
	IFS='!@' read -r nick user host <<< "$src"

	# ctcp handled specially, elsewhere
	if [[ $msg = * ]]; then
		h_ctcp "$nick" "$dest" "$msg"
		return 0
	fi

	log_read "$nick" "$dest" "$msg"

	# VM exec.
	if test_chanflags "$dest" e; then
		case "$msg" in
		'$ '*|'4$ '*|'3$ '*|'2$ '*|'sh$ '*|'k93$ '*|'k$ '*)
			IFS=' ' read -r sh cmd <<< "$msg"
			sh=${sh:0:1}
			[[ $sh = '$' || $sh = '4' ]] && sh=''
			vm_exec "$src" "$nick" "$dest" "$sh" "$cmd"
			return
			;;
		esac
	fi

	# you talkin' to me?
	if msg=$(directed_msg "$msg"); then
		direct=1
		read -r cmd args <<< "$msg"
	elif [[ $msg = ${bot["cmdch"]}* ]]; then
		msg=${msg:${#bot["cmdch"]}}
		read -r cmd args <<< "$msg"
	elif [[ $dest = $curnick ]]; then
		read -r cmd args <<< "$msg"
		#direct replies
		dest=$nick
	else
		#not directly to me..
		if test_chanflags "$dest" i; then
			if info_request "$nick" "$dest" "$msg" 1 || info_learn "$nick" "$dest" "$msg" 1; then
				return
			fi
		fi
		#scan for karma
		karma_scan "$nick" "$dest" "$msg"
		return
	fi

	# it is a command?
	if ! [[ ${cmdtbl[$cmd]+set} ]]; then
		# only after failing all this, then do infos
		if info_request "$nick" "$dest" "$msg" 0 || info_learn "$nick" "$dest" "$msg" 0; then
			return
		fi
		privmsg "$dest" "$nick: $cmd: command not found"
		return
	fi

	# find their access level
	for u in "${!acl[@]}"; do
		if [[ $src =~ $u ]]; then
			alvl=${acl[$u]}
			break
		fi
	done

	(( alvl >= ${cmdtbl[$cmd]} )) || return
	c_$cmd "$src" "$nick" "$dest" "$args"
	return
}

h_ctcp() {
	local nick=$1 dest=$2 msg=$3
	local cmd

	msg="${msg#}"
	msg="${msg%}"
	read -r cmd msg <<< "$msg"

	echo "*** $nick CTCP $dest [$cmd]${msg:+ $msg}"
	case "$cmd" in
		PING)		notice "$nick" "PING $msg" ;;
		VERSION)	notice "$nick" "VERSION some bot. written in bash!" ;;
	esac
}

### log handling/screen printing
log_read() {
	local nick=$1 dest=$2 msg=$3

	if [[ $dest = $curnick ]]; then
		printf '*%s* %s\n' "$nick" "$msg"
	else
		printf '<%s:%s> %s\n' "$nick" "$dest" "$msg"
	fi
}

log_send() {
	local cmd dest rest
	read -r cmd dest rest <<< "$1"

	case "$cmd" in
	PRIVMSG)
		printf '[q:%d] ' "${#_sendq[@]}"
		if is_chan "$dest"; then
			printf '<%s:%s>' "$curnick" "$dest"
		else
			printf '> *%s*' "$dest"
		fi
		printf ' %s\n' "${rest:1}"
		;;
	NOTICE)
		if [[ $rest = ** ]]; then
			rest=${rest///}
			read -r cmd rest <<< "${rest:1}"
			printf '[q:%d] *** CTCP [%s] reply to %s%s\n' "${#_sendq[@]}" "$cmd" "$dest" "${rest:+: $rest}"
		else
			printf '[q:%d] -%s- %s\n' "${#_sendq[@]}" "$dest" "${rest:1}"
		fi
		;;
	*)
		printf '[q:%d] >>> %s\n' "${#_sendq[@]}" "$1"
		;;
	esac
}

### outgoing handling
sendq_dowork() {
	(( (${#_sendq[@]} > 0) && (SECONDS > _sendq_last) )) || return 0

	(( _sendq_allowance += _sendq_RATE * (SECONDS - _sendq_last) ))
	(( _sendq_allowance > _sendq_MAX )) && _sendq_allowance=$_sendq_MAX

	while (( (${#_sendq[@]} > 0) && (_sendq_allowance >= _sendq_PER) ))
	do
		log_send "${_sendq[@]:(-1)}"
		irc_send "${_sendq[@]:(-1)}" q
		unset "_sendq[${#_sendq[@]}-1]"
		(( _sendq_allowance -= _sendq_PER ))
	done
	_sendq_last=$SECONDS
}

### command handling [src nick dest msg]
c_cmds()   { c_help "$@"; }
c_say()    { privmsg "$3" "$4"; }
c_dropq()  { unset _sendq; }
c_reload() { reload "$2"; }
c_raw()    { irc_sendq "$msg"; }

c_help() {
	local src=$1 nick=$2 dest=$3
	local u alvl reply

	# find their access level
	for u in "${!acl[@]}"; do
		if [[ $src =~ $u ]]; then
			alvl=${acl[$u]}
			break
		fi
	done

	for cmd in "${!cmdtbl[@]}"; do
		if (( alvl >= ${cmdtbl[$cmd]} )); then
			reply+=" [$cmd]"
		fi
	done
	if [[ $reply ]]; then
		notice "$nick" "Commands available to you:$reply"
	fi
}

c_tell() {
	read -r dest msg <<<"$4"
	privmsg "$dest" "$msg"
}

c_cat() {
	[[ $4 = */* ]] && return 1

	while IFS= read -r line; do
		notice "$2" "$line"
	done < "$4"
}

c_whoami() {
	local src=$1 nick=$2 dest=$3
	local alvl u

	for u in "${!acl[@]}"; do
		if [[ $src =~ $u ]]; then
			alvl=${acl[$u]}
			break
		fi
	done

	if (( alvl > 0 )); then
		privmsg "$dest" "[$u] alvl:$alvl"
	else
		privmsg "$dest" "You're nobody!"
	fi
}

c_forget() {
	local nick=$2 dest=$3 msg=$4

	if [[ ${info[$msg]+set} ]]; then
		unset "info[$msg]"
		privmsg "$dest" "$nick: Ok. I forgot $msg."
	else
		privmsg "$dest" "$nick: I never knew $msg."
	fi
}

c_info() {
	local nick=$2 dest=$3 reply="terms:" term

	for term in "${!info[@]}"; do
		if (( ${#reply} + ${#term} > 200 )); then
			notice "$nick" "$reply"
			reply="terms:"
		fi
		reply+=" $term"
	done

	[[ ${reply+set} ]] && notice "$nick" "$reply"
}

c_uptime() {
	local nick=$2 dest=$3
	local d h m s up

	read -r d h m s <<< "$(sec_to_dhms $SECONDS)"
	printf -v up '%d days, %2d:%02d, %2d channels' "$d" "$h" "$m" "${#channels[@]}"
	privmsg "$dest" "$curnick up $up"
}

c_karma() {
	local nick=$2 dest=$3 msg=$4 reply
	msg=${msg,,}
	if [[ $msg = *" "* ]]; then
		for word in $msg; do
			msg=${msg//./ }
			reply+="$word has ${karma[$word]:-no} karma. "
		done
		privmsg "$dest" "$reply"
	else
		word=${msg//./ }
		privmsg "$dest" "$msg has ${karma[$msg]:-no} karma."
	fi
}

c_top10() {
	local nick=$2 dest=$3 k reply


	while read -r num data
	do
		reply+=" [$data]:$num"
	done < <(for k in "${!karma[@]}"
		do
			printf '%d %s\n' "${karma[$k]}" "$k"
		done |sort -rnk1
	)
	privmsg "$dest" "Karma top 10: $reply"
}

c_google() {
	local nick=$2 dest=$3 term=$4
	local title url

	json=$(curl -s --get --data-urlencode "q=$term" 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0')
	title=$(json responseData results 0 titleNoFormatting <<< "$json")
	url=$(json responseData results 0 url <<< "$json")
	privmsg "$dest" "$nick: $title $url"
}

# include forecast
c_wxf() { c_wx "$@" 1; }

c_wx() {
	local nick=$2 dest=$3 place=${4,,} fc=$5
	local json title temp feels wind day fctext reply

	json=$(wget -q -O - "http://api.wunderground.com/api/1f524830dcb29a41/conditions/forecast/geolookup/pws:${pws}/q/${place}.json")

	# was ambiguous?
	reply=$(json response results 0 l <<< "$json")
	if [[ $reply ]]; then
		json=$(wget -q -O - "http://api.wunderground.com/api/1f524830dcb29a41/conditions/forecast/geolookup/${reply}.json")
	fi

	# was error?
	title=$(json response error description <<< "$json")
	if [[ $title ]]; then
		privmsg "$dest" "$nick: $title"
		return
	fi

	# is empty...?
	title=$(json current_observation display_location full <<< "$json")
	if [[ -z $title ]]; then
		privmsg "$dest" "$nick: Bugger if I know."
		return
	fi
	if ! (( fc )); then
		temp=$(json current_observation temperature_string <<< "$json")
		feels=$(json current_observation feelslike_string <<< "$json")
		wind=$(json current_observation wind_string <<< "$json")
		privmsg "$dest" "$nick: $title -- $temp, feels like $feels. Wind $wind."
	else
		unset reply
		for ((day = 0; day < 3; day++)); do
			title=$(json forecast simpleforecast forecastday "$day" date weekday_short <<< "$json")
			fctxt=$(json forecast simpleforecast forecastday "$day" conditions <<< "$json")
			reply+=" $title: $fctxt"
		done
		privmsg "$dest" "$nick: ${reply:1}"
	fi
}

c_pws() {
	local nick=$2 dest=$3 msg=${4,,}

	case "$msg" in
		on) pws=1; privmsg "$dest" "$nick: Ok. PWS is now on." ;;
		off) pws=0; privmsg "$dest" "$nick: Ok. PWS is now off." ;;
		*) privmsg "$dest" "$nick: PWS is currently $pws" ;;
	esac
}

c_chan() {
	local nick=$2 dest=$3 args=${4,,}
	local chan flags
	read -r chan flags <<< "$args"

	if [[ -z $flags ]]; then
		if [[ ${channels[$chan]+set} ]]; then
			privmsg "$dest" "Flags for $chan: ${channels[$chan]}"
		else
			privmsg "$dest" "I'm not familiar with $chan"
		fi
		return
	fi
	channels[$chan]=$flags
	irc_send "JOIN :$chan"
}

c_wxs() {
	local nick=$2 dest=$3 place=${4,,}
	local json reply

	json=$(wget -q -O - "http://api.wunderground.com/api/1f524830dcb29a41/conditions/pws:${pws}/q/${place}.json")
	reply=$(json response error description <<< "$json")
	if [[ $title ]]; then
		privmsg "$dest" "$nick: $title"
		return
	fi
	reply="$(json current_observation station_id <<< "$json") -- "
	reply+=$(json current_observation observation_location full <<< "$json")

	privmsg "$dest" "$nick: Observation Station $reply."
}

### command subfuncs that don't really fit elsewhere
test_chanflags() {
	local chan=$1 flags=${2,,}
	local i l f

	is_chan "$chan" || return 0	# do anything in private ;)
	[[ ${channels[$chan]+set} ]] || return 1

	l=${#flags}
	for ((i = 0; i < l; i++)); do
		[[ ${channels[$chan]} = *${flags:i:1}* ]] && return 0
	done

	return 1
}

sec_to_dhms() {
	local s=$1 d h m s

	((
		d  = s / 86400,
		s -= d * 86400,
		h  = s / 3600,
		s -= h * 3600,
		m  = s / 60,
		s -= h * 60
	))

	echo "$d $h $m $s"
}

directed_msg() {
	local msg=$1
	local retval=1

	if [[ $msg = ${curnick}[:,\ ]* ]]; then
		IFS=':, ' read -r _ msg <<< "$msg"
		retval=0
	fi

	echo "$msg"
	return $retval
}

# return 1 only if it did not seem like a valid info request!
info_request() {
	local nick=$1 dest=$2 msg=$3 quiet=$4
	local key reply

	# reply to what/who/where is <term>, or simply <term>?
	case "${msg,,}" in
	"what is "*|"who is "*|"where is "*)
		msg=${msg#* * }
		;;
	*)
		#lame. it's a learn instead... my logic is flawed?
		[[ $msg = *' is '* ]] && return 1
		if (( quiet )) && [[ $msg != *'?' ]]; then
			return 1
		fi
		;;
	esac
	msg=${msg%\?}
	key=${msg,,}

	echo "*** Info request [$msg]"
	if [[ -z ${info[$key]} ]]; then
		echo "    but I don't know it."
		if (( quiet )); then
			return 1
		else
			privmsg "$dest" "$nick: I don't know about \"$key\"."
			return 0
		fi
	fi

	reply=${info[$key]}
	reply=${reply/'$nick'/$nick}
	case "$reply" in
	'<action>'*)
		reply=${reply#* }
		privmsg "$dest" "ACTION $reply"
		;;
	'<reply>'*)
		reply=${reply#* }
		privmsg "$dest" "$reply"
		;;
	*)
		privmsg "$dest" "$nick: $msg is $reply"
		;;
	esac

	return 0
}

info_learn() {
	local nick=$1 dest=$2 msg=$3 quiet=$4
	local key val change=0

	[[ $msg = *' is '* ]] || return 1

	key=${msg%% is *}
	val=${msg#* is }

	if [[ $key = 'no, '* ]]; then
		(( quiet )) || change=1
		key=${key#no, }
	fi

	if (( change == 0 )) && [[ ${info[$key]+set} ]]; then
		(( quiet )) || privmsg "$dest" "$nick: I already know $key: ${info[$key]}"
		return 0
	fi

	echo "*** Info add [$key]=[$val]"
	info[$key]=$val
	(( quiet )) || privmsg "$dest" "$nick: Ok."
	return 0
}

vm_exec() {
	local src=$1 nick=$2 dest=$3 sh=$4 cmd=$5
	local output line c url

	echo "[$src] exec [$sh] $cmd"

	mapfile -t output < <(runqemu "$sh" "$cmd")

	if (( ${#output[@]} > 3 )); then
		url=$(IFS=$'\n' curl -0 -F 'text=<-' http://san.aq <<<"${output[*]}")
		read -r _ url <<< "$url"
	elif (( ${#output[@]} == 0 )); then
		output='no output within specified time limit.'
	fi

	for line in "${output[@]}"; do
		(( c++ < 3 )) || break
		privmsg "$dest" "$nick: $line"
	done

	[[ $url ]] && privmsg "$dest" "$nick: ...etc: $url"
}

url_catcher() {
	local nick=$1 dest=$2 url=$3
	local title

	title=$(./htitle <(curl -Ls "$url"))
	[[ $title ]] || return

	url=$(IFS=$'\n' curl -0 -F "url=$url" http://san.aq)
	read -r _ url <<< "$url"

	privmsg "$dest" "[$url] $title"
}

karma_scan() {
	local nick=$1 dest=$2 msg=$3
	local reqs=0

	test_chanflags "$dest" "uk" || return

	for word in $msg; do
		if [[ $word = http://* ]] && test_chanflags "$dest" u; then
			url_catcher "$nick" "$dest" "$word"
		fi
		test_chanflags "$dest" k || continue

		word=${word//./ }
		word=${word,,}
		case "$word" in
		*?++)
			word=${word%??}
			(( reqs++ ))
			karma_self "$dest" "$nick" "$word" && continue
			(( karma[$word]++ ))
			privmsg "$dest" "$word has ${karma[$word]:-no} karma."
			;;
		*?--)
			word=${word%??}
			(( reqs++ ))
			karma_self "$dest" "$nick" "$word" && continue
			(( karma[$word]-- ))
			privmsg "$dest" "$word has ${karma[$word]:-no} karma."
			;;
		esac
	done

	return $(( reqs > 0 ))
}

karma_self() {
	local dest=$1 nick=$2 word=$3

	[[ $nick = $word ]] || return 1

	privmsg "$dest" "Got an ego problem, $nick? We'll bring that down a notch!"
	(( karma[$word]-- ))
	privmsg "$dest" "$word has ${karma[$word]} karma."

	return 0
}

### script handling
cleanup() {
	declare -p karma info channels >"$savefile"
	irc_send "QUIT :Recv'd SIGTERM or something"
	exec 3>&-
	sleep 1
}

reload() {
	local tmpfile

	declare -p karma info channels >"$savefile"
	# cannot export arrays. cannot source a fifo. must use temp file. :(
	tmpfile=$(mktemp)
	declare -p karma info _sendq _origargs >"$tmpfile" 2>/dev/null
	# code injection! :O
	[[ $1 ]] && printf 'notice "%s" "reload %d complete."\n' "$1" "$reloads" >>"$tmpfile"

	# could be written without eval but whateves.
	eval exec {4..255}'>&-'	# :O
	echo "*** Exec: ${_origargs[@]} -l $tmpfile"
	exec "${_origargs[@]}" -l "$tmpfile"
}

### main
main() {
	local retval line

	while irc_connect; do
		[[ $curnick ]] || echo "*** Connection complete."
		retval=0
		while IFS= read -t .5 -u 3 -r line || { retval=$?; (( retval > 128 )); }; do
			if (( retval > 128 )); then
				retval=0
			else
				line=${line%$'\n'}
				line=${line%$'\r'}
				irc_parse "$line"
			fi
			sendq_dowork
		done #read loop
		echo "*** READ ERROR $retval: $errtext"
		unset curnick
	done #reconnect loop
}

[[ -r $savefile ]] && . "$savefile"
trap cleanup EXIT
trap reload SIGHUP

# FIXME: real option parsing
if [[ $1 = '-l' ]]; then
	echo "*** Reloading arrays from $2"
	printf '\n\n'
	cat "$2"
	printf '\n\n'
	source "$2"
	unlink "$2" && echo "*** $2 removed."
fi

main
